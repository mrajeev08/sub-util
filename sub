#!/usr/bin/env Rscript
suppressPackageStartupMessages(library("argparse"))

# create parser object
parser <- ArgumentParser()

# specify our desired options
# by default ArgumentParser will add a help option
# use sub -h/ --help 

# For gpu
parser$add_argument("--noGPU", action="store_true", default=TRUE,
help="Do not write GPU line")
parser$add_argument("-g", "--gpu", action="store_false",
dest="noGPU", help="Write the GPU line")

# For multiple nodes with MPI vs single node
parser$add_argument("-mn", "--multinode", action="store_true", default=TRUE,
help="Do not write the node line (multinode jobs with rMPI) DEFAULT")
parser$add_argument("-sn", "--single", action="store_false",
dest="multinode", help="Write the node line for running job on single node")
parser$add_argument("-t", "--time", type="integer", default=24,
help="Number of hours to run", metavar="number")
parser$add_argument("-n", "--ntasks", type="integer", default=1,
help="Number of tasks across all nodes", metavar="number")
parser$add_argument("-mem", "--memCPU", type = "integer", default=4000, 
help="Megabyte of memory per CPU", metavar = "number")
parser$add_argument("-sp", "--scriptPath", help="Name of R script", default="myscript.R")
parser$add_argument("-jn", "--jobName", help="Name of job/slurm script", default="myjob")
parser$add_argument("-wt", "--wait", help="time to wait before checking, default is 1m", default="1m")
parser$add_argument("-@", "--email", action="store_true", help="whether to email or not", default = TRUE)
parser$add_argument("-n@", "--noemail", action="store_false", dest="email", help="don't email")

# For writing local bash script
parser$add_argument("-dd", "--destdir", help = "Directory to pull TO default is Null so will look in Rscript passed for sync_to", default= 'NULL')
parser$add_argument("-re", "--remote", help = "Remote directory to pull FROM, same as per destdir", default = 'NULL')

# get command line options, if help option encountered print help and exit,
# otherwise if options not found on command line then set defaults,
args <- parser$parse_args()

hours <- trimws(toString(args$time))
ntasks <- trimws(toString(args$ntasks))
memCPU <- trimws(toString(args$memCPU))
jobName <- trimws(toString(args$jobName))
scriptPath <- trimws(toString(args$scriptPath))
wait <- trimws(toString(args$wait))

# parse from Rscript
if(is.null(args$destdir)) {
    destdir <- trimws(toString(args$destdir))
} else {
    destdir <- system2("grep", args = paste("sync_to ", scriptPath, " | cut -f 2 -d -", sep = ""),
                        stdout = TRUE)
    destdir <- unlist(strsplit(destdir, "\""))[2]
    print(paste("will pull to: ", destdir))
}

if(is.null(args$remote)) {
    remote <- trimws(toString(args$remote))
} else {
    remote <- system2("grep", args = paste("sync_from ", scriptPath, " | cut -f 2 -d -", sep = ""),
                        stdout = TRUE)
    remote <- unlist(strsplit(remote, "\""))[2]
    print(paste("will pull from: ", remote))
}

sink(paste("bash/", jobName, ".slurm", sep = ""))
cat("#!/bin/bash\n")
cat(paste("#SBATCH --job-name=", jobName,"	 # create a short name for your job\n", sep=""))

if ( !args$multinode ) { cat("#SBATCH --nodes=1		      # node count\n") }
cat(paste("#SBATCH --ntasks=", ntasks, "	        # total number of tasks across all nodes\n", sep=""))
cat("#SBATCH --cpus-per-task=1	 # cpu-cores per task (>1 if multithread tasks)\n")
cat(paste("#SBATCH --mem-per-cpu=", memCPU, "	 # mem per CPU\n", sep=""))
if ( !args$noGPU ) { cat("#SBATCH --gpus=gres:1            # number of gpus per node\n") }
cat(paste("#SBATCH --time=", hours, ":00:00          # total run time limit (HH:MM:SS)\n", sep=""))

if ( args$email ) { 
cat("#SBATCH --mail-type=begin        # send mail when process begins\n")
cat("#SBATCH --mail-type=end	        # send email when job ends\n")
cat("#SBATCH --mail-user=mrajeev@princeton.edu\n")
}
cat("\n")

if ( args$multinode ) {
    cat("export OMPI_MCA_btl='tcp,self,sm'\n")
    cat("module load openmpi/gcc/2.0.2\n")
    cat(paste("srun Rscript ", scriptPath, "\n", sep = ""))
} else {
    cat(paste("Rscript ", scriptPath, "\n", sep = ""))
}
sink()

sink(paste("bash/", jobName, ".sh", sep = ""))
cat("#!/bin/bash\n")
cat("ssh -T mrajeev@della <<HERE\n")
cat("    cd MadaAccess  # change to repo\n")
cat(paste("    jid=\\$(sbatch bash/", jobName, ".slurm | cut -c 21-)\n", sep = ""))
cat("    echo \"Here's the job id: \\$jid\"\n")
cat("    jstat=\\$(sacct -j \"\\$jid\" -u mrajeev | head -n 3)\n")
cat("    echo \"Here's the job stat: \\$jstat\"\n")
cat("    until grep -q \"COMPLETED\\|FAILED\\|CANCELLED\" <<< \\$jstat  # if completed or failed\n")
cat("    do\n")
cat("        echo waiting   # updating\n")
cat("        jstat=\\$(sacct -j \"\\$jid\" -u mrajeev | head -n 3)\n")
cat("        echo \"Here's the job stat: \\$jstat\"\n")
cat(paste("        sleep ", wait, " # time to sleep for (base it on how long the job should take)\n", sep = ""))
cat("    done\n")
cat("    if grep -q \"FAILED\\CANCELLED\" <<< \\$jstat\n")
cat("    then\n        echo \"Failed or cancelled\"\n")
cat("        exit\n")
cat("    else\n        logout\n    fi\nHERE\n")
cat("        sleep 1m    # sleep again as sometimes takes a while to write output\n")
cat(paste("        rsync -rLvzt", remote, destdir, "\n", sep = " "))
sink()

# find rsync script and use it to push up to remote
rsync <- list.files()[grep("rsync", list.files())]
system2("bash", paste0(rsync))
 
# bash job.sh (running locally!)
system2("bash", args = paste("bash/", jobName, ".sh", sep = ""))

# beepme pls!
suppressPackageStartupMessages(library("beepr"))
beep()
